{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 48, "column": 0}, "map": {"version":3,"sources":["file:///Users/einarjaeger/Documents/GitHub/Photovault/src/lib/auth.ts"],"sourcesContent":["/**\n * Better Auth Server Configuration\n *\n * Key Anchoring: Each user's vault_key_hash is locked to their account.\n * This prevents using one account for multiple independent vaults.\n */\n\nimport { betterAuth } from \"better-auth\";\nimport { Pool } from \"pg\";\n\n// Supabase Postgres connection with SSL\nif (process.env.NODE_ENV === \"production\" && !process.env.DATABASE_URL) {\n    console.error(\"CRITICAL: DATABASE_URL is missing in production!\");\n}\n\nif (process.env.DATABASE_URL && process.env.DATABASE_URL.includes(\"db.jextayidnmtsoofug\") && !process.env.DATABASE_URL.includes(\"nig\")) {\n    console.warn(\"WARNING: DATABASE_URL appears to be TRUNCATED (missing 'nig')\");\n}\n\nconst pool = new Pool({\n    connectionString: process.env.DATABASE_URL,\n    ssl: {\n        rejectUnauthorized: false, // Required for Supabase connection\n    },\n});\n\nexport const auth = betterAuth({\n    database: pool,\n\n    // Email/Password authentication\n    emailAndPassword: {\n        enabled: true,\n        requireEmailVerification: false, // For MVP, can enable later\n        minPasswordLength: 8,\n    },\n\n    // User configuration with vault_key_hash for key anchoring\n    user: {\n        fields: {\n            emailVerified: \"email_verified\",\n            createdAt: \"created_at\",\n            updatedAt: \"updated_at\",\n        },\n        additionalFields: {\n            vault_key_hash: {\n                type: \"string\",\n                required: false,\n                defaultValue: null,\n                input: false, // Cannot be set by client directly\n            },\n        },\n    },\n\n    // Session configuration\n    session: {\n        expiresIn: 60 * 60 * 24 * 30, // 30 days\n        updateAge: 60 * 60 * 24, // Update session every 24 hours\n        fields: {\n            userId: \"user_id\",\n            expiresAt: \"expires_at\",\n            ipAddress: \"ip_address\",\n            userAgent: \"user_agent\",\n            createdAt: \"created_at\",\n            updatedAt: \"updated_at\",\n        },\n        cookieCache: {\n            enabled: true,\n            maxAge: 60 * 5, // 5 minutes cache\n        },\n    },\n\n    // Account configuration\n    account: {\n        fields: {\n            userId: \"user_id\",\n            accountId: \"account_id\",\n            providerId: \"provider_id\",\n            accessToken: \"access_token\",\n            refreshToken: \"refresh_token\",\n            accessTokenExpiresAt: \"access_token_expires_at\",\n            refreshTokenExpiresAt: \"refresh_token_expires_at\",\n            idToken: \"id_token\",\n            createdAt: \"created_at\",\n            updatedAt: \"updated_at\",\n        },\n    },\n\n    // Verification configuration\n    verification: {\n        fields: {\n            expiresAt: \"expires_at\",\n            createdAt: \"created_at\",\n            updatedAt: \"updated_at\",\n        },\n    },\n\n    // Advanced security settings\n    advanced: {\n        useSecureCookies: process.env.NODE_ENV === \"production\",\n        generateId: () => crypto.randomUUID(),\n    },\n\n    // Rate limiting\n    rateLimit: {\n        enabled: true,\n        window: 60, // 1 minute window\n        max: 100, // Increased to 100 to handle startup bursts\n    },\n\n    // Trusted origins for CORS\n    trustedOrigins: [\n        process.env.BETTER_AUTH_URL || \"http://localhost:3000\",\n    ],\n});\n\n// Type inference for client\nexport type Auth = typeof auth;\n"],"names":[],"mappings":";;;;AAAA;;;;;CAKC,GAED;AAAA;AACA;;;;;;;AAEA,wCAAwC;AACxC;;AAIA,IAAI,QAAQ,GAAG,CAAC,YAAY,IAAI,QAAQ,GAAG,CAAC,YAAY,CAAC,QAAQ,CAAC,2BAA2B,CAAC,QAAQ,GAAG,CAAC,YAAY,CAAC,QAAQ,CAAC,QAAQ;IACpI,QAAQ,IAAI,CAAC;AACjB;AAEA,MAAM,OAAO,IAAI,qJAAI,CAAC;IAClB,kBAAkB,QAAQ,GAAG,CAAC,YAAY;IAC1C,KAAK;QACD,oBAAoB;IACxB;AACJ;AAEO,MAAM,OAAO,IAAA,uKAAU,EAAC;IAC3B,UAAU;IAEV,gCAAgC;IAChC,kBAAkB;QACd,SAAS;QACT,0BAA0B;QAC1B,mBAAmB;IACvB;IAEA,2DAA2D;IAC3D,MAAM;QACF,QAAQ;YACJ,eAAe;YACf,WAAW;YACX,WAAW;QACf;QACA,kBAAkB;YACd,gBAAgB;gBACZ,MAAM;gBACN,UAAU;gBACV,cAAc;gBACd,OAAO;YACX;QACJ;IACJ;IAEA,wBAAwB;IACxB,SAAS;QACL,WAAW,KAAK,KAAK,KAAK;QAC1B,WAAW,KAAK,KAAK;QACrB,QAAQ;YACJ,QAAQ;YACR,WAAW;YACX,WAAW;YACX,WAAW;YACX,WAAW;YACX,WAAW;QACf;QACA,aAAa;YACT,SAAS;YACT,QAAQ,KAAK;QACjB;IACJ;IAEA,wBAAwB;IACxB,SAAS;QACL,QAAQ;YACJ,QAAQ;YACR,WAAW;YACX,YAAY;YACZ,aAAa;YACb,cAAc;YACd,sBAAsB;YACtB,uBAAuB;YACvB,SAAS;YACT,WAAW;YACX,WAAW;QACf;IACJ;IAEA,6BAA6B;IAC7B,cAAc;QACV,QAAQ;YACJ,WAAW;YACX,WAAW;YACX,WAAW;QACf;IACJ;IAEA,6BAA6B;IAC7B,UAAU;QACN,kBAAkB,oDAAyB;QAC3C,YAAY,IAAM,OAAO,UAAU;IACvC;IAEA,gBAAgB;IAChB,WAAW;QACP,SAAS;QACT,QAAQ;QACR,KAAK;IACT;IAEA,2BAA2B;IAC3B,gBAAgB;QACZ,QAAQ,GAAG,CAAC,eAAe,IAAI;KAClC;AACL"}},
    {"offset": {"line": 165, "column": 0}, "map": {"version":3,"sources":["file:///Users/einarjaeger/Documents/GitHub/Photovault/src/app/api/auth/update-vault-key/route.ts"],"sourcesContent":["/**\n * API Route: Update User's Vault Key Hash\n *\n * This endpoint anchors the user's encryption key hash to their account.\n * Once set, the vault_key_hash cannot be changed (prevents using one account for multiple vaults).\n */\n\nimport { NextRequest, NextResponse } from \"next/server\";\nimport { auth } from \"@/lib/auth\";\nimport { headers } from \"next/headers\";\nimport { Pool } from \"pg\";\n\n// Use the same database connection as Better Auth\nconst pool = new Pool({\n    connectionString: process.env.DATABASE_URL,\n    ssl: {\n        rejectUnauthorized: false,\n    },\n});\n\nexport async function POST(request: NextRequest) {\n    try {\n        // Verify the user is authenticated\n        const session = await auth.api.getSession({\n            headers: await headers(),\n        });\n\n        if (!session?.user) {\n            return NextResponse.json(\n                { error: \"Unauthorized\" },\n                { status: 401 }\n            );\n        }\n\n        const { userId, keyHash } = await request.json();\n\n        // Verify the request is for the authenticated user\n        if (session.user.id !== userId) {\n            return NextResponse.json(\n                { error: \"Forbidden - cannot update another user's vault\" },\n                { status: 403 }\n            );\n        }\n\n        // Check if user already has a vault_key_hash (key anchoring)\n        const currentUser = session.user as { vault_key_hash?: string };\n        if (currentUser.vault_key_hash) {\n            return NextResponse.json(\n                { error: \"Vault key already anchored to this account\" },\n                { status: 400 }\n            );\n        }\n\n        // Validate keyHash format (should be 16-character hex string)\n        if (!keyHash || typeof keyHash !== \"string\" || !/^[a-f0-9]{16}$/.test(keyHash)) {\n            return NextResponse.json(\n                { error: \"Invalid key hash format\" },\n                { status: 400 }\n            );\n        }\n\n        // Update the user's vault_key_hash directly in the database\n        const result = await pool.query(\n            'UPDATE \"user\" SET vault_key_hash = $1, updated_at = NOW() WHERE id = $2 AND vault_key_hash IS NULL',\n            [keyHash, userId]\n        );\n\n        if (result.rowCount === 0) {\n            // Either user doesn't exist or already has a vault_key_hash\n            return NextResponse.json(\n                { error: \"Failed to update vault key - may already be set\" },\n                { status: 400 }\n            );\n        }\n\n        return NextResponse.json({ success: true });\n    } catch (error) {\n        console.error(\"Failed to update vault key hash:\", error);\n        return NextResponse.json(\n            { error: \"Internal server error\" },\n            { status: 500 }\n        );\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;;;;;CAKC,GAED;AACA;AACA;AACA;;;;;;;;;;AAEA,kDAAkD;AAClD,MAAM,OAAO,IAAI,qJAAI,CAAC;IAClB,kBAAkB,QAAQ,GAAG,CAAC,YAAY;IAC1C,KAAK;QACD,oBAAoB;IACxB;AACJ;AAEO,eAAe,KAAK,OAAoB;IAC3C,IAAI;QACA,mCAAmC;QACnC,MAAM,UAAU,MAAM,4HAAI,CAAC,GAAG,CAAC,UAAU,CAAC;YACtC,SAAS,MAAM,IAAA,4IAAO;QAC1B;QAEA,IAAI,CAAC,SAAS,MAAM;YAChB,OAAO,gJAAY,CAAC,IAAI,CACpB;gBAAE,OAAO;YAAe,GACxB;gBAAE,QAAQ;YAAI;QAEtB;QAEA,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,QAAQ,IAAI;QAE9C,mDAAmD;QACnD,IAAI,QAAQ,IAAI,CAAC,EAAE,KAAK,QAAQ;YAC5B,OAAO,gJAAY,CAAC,IAAI,CACpB;gBAAE,OAAO;YAAiD,GAC1D;gBAAE,QAAQ;YAAI;QAEtB;QAEA,6DAA6D;QAC7D,MAAM,cAAc,QAAQ,IAAI;QAChC,IAAI,YAAY,cAAc,EAAE;YAC5B,OAAO,gJAAY,CAAC,IAAI,CACpB;gBAAE,OAAO;YAA6C,GACtD;gBAAE,QAAQ;YAAI;QAEtB;QAEA,8DAA8D;QAC9D,IAAI,CAAC,WAAW,OAAO,YAAY,YAAY,CAAC,iBAAiB,IAAI,CAAC,UAAU;YAC5E,OAAO,gJAAY,CAAC,IAAI,CACpB;gBAAE,OAAO;YAA0B,GACnC;gBAAE,QAAQ;YAAI;QAEtB;QAEA,4DAA4D;QAC5D,MAAM,SAAS,MAAM,KAAK,KAAK,CAC3B,sGACA;YAAC;YAAS;SAAO;QAGrB,IAAI,OAAO,QAAQ,KAAK,GAAG;YACvB,4DAA4D;YAC5D,OAAO,gJAAY,CAAC,IAAI,CACpB;gBAAE,OAAO;YAAkD,GAC3D;gBAAE,QAAQ;YAAI;QAEtB;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,SAAS;QAAK;IAC7C,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,oCAAoC;QAClD,OAAO,gJAAY,CAAC,IAAI,CACpB;YAAE,OAAO;QAAwB,GACjC;YAAE,QAAQ;QAAI;IAEtB;AACJ"}}]
}